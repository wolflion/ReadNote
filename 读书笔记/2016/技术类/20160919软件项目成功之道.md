##  缘起
+ 看起来是很薄的一本书，不到200页，以为一周就能读完呢，谁知道也看了很久。


##  内容
###  chap1 绪论
+ *你很难有时间坐下来静心读点东西，做些试验，得出哪些做法可行以及如何在欠的工作室合理运用。*
+ 1.1 习惯性优秀
	+ **要有意识地搜寻好习惯，并把它们加到日常生活当中**，一流的产品只不过是好习惯的副产品。 
	+ *不要偶然地养成某些习惯，要有意识地主动选择习惯。*
+ 1.2 务实观点 
	+ *具体做事的人应该更了解需要解决哪些具体问题。*
+ 1.3 路线图
+ 1.4 继续前进
	+ 先阅读，然后动手尝试。根据你的环境，保留那些适用的想法，其他的断然舍弃。


###  chap2 工具和基础设施
+ 1 在沙箱中开发( *sandbox development*)
    + 除了开发机器和存储库外，还有一个**构建机**（无人照管的服务器）。它只是从存储库得到所有最新的源代码，反复地构建和测试。构建的结果就是产品发布。
+ 2 管理资产
	+ *生成一个简短(只有一页)的快速入门指南，列出如何使用这个系统完成常见的操作。*
+ 3 建立构建脚本
	+ 只需一个命令就能运行的手动构建系统。
+ 4 自动构建
	+ 开源的CI工具：CruiseControl.
+ 5 跟踪问题
	+ **issue**在哪个版本中存在？哪个客户遇到？有多严重？内部是否可重现？客户的环境是怎样的？最早出现在哪个版本中？在哪个版本中得到了修正？谁修正了？谁验证了？
+ 6 跟踪特性
	+ *特性*：是对一个现有产品的改进。
+ 7 使用自动化测试框架
	+ MetaCheck
	+ *一定要投入必要的时间找到一个适合你的具体环境的框架，然后学习如何有效地加以使用。*
+ 8 选择工具
	+ 应当花些时间来研究哪些工具满足你的需要， **要在每个领域中寻求“最出类拔萃”的工具**
+ 9 何时结束试验
	+ **只有经验能够告诉你一种技术有什么缺点。**
	+ *如果你希望人们学习某种技术，要通过反馈来确保他们确实在学习。*

###  chap3 实用项目技术
+ 10 按照任务清单工作
    + *每天早晨建立一个列表，确定需要完成的工作，并确定工作的优先级。*
    + **将任务转换成可测量的目标**
+ 11 技术领导人
    + 职责
        + 为团队成员设定方向  {了解团队成员的进度，遇到的问题以及估计的完成日期，建立项目健康度的全局视图，同时跟踪进展。}
        + 管理项目的特性列表
        + 为项目的特性确定优先级
        + 隔离你的团队，使他们不受外部干扰
    + *技术领导人要把时间分摊到开发任务和管理任务上，而不能只停留在一个领域。*
    + *通过思考如何成为一个技术领导人，你会成为一个更棒的开发人员。*
    + 作为团队的技术领导人，你应该能顺利地回答以下问题：
        + 你知道团队的每一个成员都在做什么吗？
        + 你能不能在5分钟内生成一个关于项目状态的总结？
        + 产品接下来要实现的5到10个特性是什么？
        + 你能不能很容易地列出产品中优先级最高的缺陷？
        + 你为团队成员解决的最近问题是什么？
        + 如果一个团队成员需要解决一个重要问题，他会来向你求助吗？
+ 12 每天都要协调和沟通
    + 每个团队成员会简要地告诉大家他在做什么，遇到了哪些问题。*每个人花的时间不要超过1~2分钟。*
+ 13 审查所有代码
    + **模式** ：指记录和命名正式项目中常见问题(及其解决方案)的实践。
    + *首先不要造成伤害* 并不只是一个代码审查规则，因为这是一个普遍适用的一般原则。
    + 我们的目标是学习如何创造性地思考，同时改善你的产品。 *要学习从不同角度查找自己的问题。*  
    + **你从代码审查中学到什么了吗？**
    + *宁可审查太少代码，也不要太多。*
+ 14 发送代码变更通知
    + 通知邮件应当包括以下内容
        + 审查人员的名字
        + 代码变更或补充的目的
        + 新代码和老代码之间的差别
    + 好处
        + 让更优秀的人review你的代码，并能给出更优秀的建议
        + 如果一周都没有提交代码，技术领导人可能会关注到你有没有陷入困境或者脱离正轨。

###  chap4 曳光弹(Tracer Bullet Development)开发
+ *你的过程只要回答两个真正的问题*
	+ 它对你有效吗？
	+ 它是可持续的吗？
+ 毫无例外，我们见过的每一个没有明确定义过程的工作室都无法按时交付有期望特性集的产品。
+ *要花些时间搞清楚你在做什么以及为什么这么做。*
+ **从一个较小的项目开始实践，感受一下TBD是如何工作的。**
	+ 定义系统对象
	+ 定义系统对象间的接口
	+ 编写接口桩
	+ 实现桩之间的相互通信
	+ 在桩中填入功能代码

###  chap5 常见问题及解决办法
+ *大多数人在回避问题上花费的时间和精力比他们尝试解决问题所下的功夫还要多。--亨利.福特*
+ 继承了一个遗留产品，要对它进行维护和改进。
	+ 掌握这个产品最快的方法是？构建它，使其自动化，最后测试之。
	+ **测试之前不要修改遗留代码。** 
+ 测试不可测试的代码
	+ 增量改进和保持前进。
	+ 清理不可测试的代码。
+ 18. 特性不断破坏
    + **修正这个问题最快的办法：** 增加一个自动测试套件。要让产品或平台尽快稳定。
+ 19. 测试？我们早就不用了
+ 20. 不过我这里没问题！
    + 要么我这修改代码，要么客户修改配置。
+ 21. 集成代码很痛苦
    + 经常集成，并持续构建和测试 
+ 22. 不能可靠地构建产品
    + *没有清楚了解你的构建过程，以及所有构建步骤。*
+ 23. 客户不满意
    + **要明确客户真正想要什么，往往是项目中最困难的部分。**
    + 尽早而且经常发布真实演示系统
+ 24. 有一个另类的开发人员
+ 25. 你的经理不满意
    + **怎么让你的经理满意？** 那就是沟通。一定要让你的经理总能了解到你在做什么，以及为什么这么做。
    + **真正的问题是：**如何有效地与你的经理沟通。
    + *对所做工作一个总结。* 如：“我帮助Trew解决AIX上的一个安装问题”
    + *各项工作的更多详细信息。* 如：“Trew和我工作了4个小时想要在AIX5.1上安装Gizmo。最后5.2上可以，但5.1上打开的文件句柄数方面有一个问题。与John和Mark查看这个问题后，最终确定这实际上是安装程序代码中一个底层问题，我们联系了Steve来修正这个问题。”
+ 26. 团队不能很好地合作
    + **会面才能建立真正的团队**      
    + *每日例会；提交代码前让团队成员相互审查代码；每周搞一次午餐聚会*
+ 27. 在根本问题上无法得到“认可”
    + *不论概念多好，人们对一个实际示例的反应都会远远超出单纯的演讲。*
    + **如果一个船长翻过船，将很难再受命上船......**
+ 28. 新实践没有帮助
    + 要“站在巨人的肩上”。最好的办法是**学习巨人们正在使用的实践，并亲自着手应用。**
    + *让管理层逐渐认可*
+ 29. 没有自动测试
    + **测试有bug的代码。** 使用缺陷驱动测试来明确要编写哪些测试。
+ 30. 我们只是低级别开发人员，没有人指导我们
    + 低级别成员可以任意讨论他们的问题，而不必明确地请求帮助。
    + 高级别成员可以在这里分享解决方法，而不必单独地给每一个团队成员面授机宜。
    + 引入代码审查
+ 31. 我们在一个“死亡之旅”项目中
    + 建立新的项目进度；为任务进行时间估计；为项目建立一个时间表。
+ 32. 特性不段蔓延
    + 确定这个特性与其它特性相比有多重要，为它指定一个优先级，并指派一个开发人员来实现它。
+ 33. 我们永远也完不了
    + **任务清单是一个活动的文档，生活处处有变化**
    + 关于特性列表的指导原则
        + 如果任务的估计时间超过一周，把它分解为子任务。
        + 不到一天就能完成的任务，不应当放在任务清单中。
        + 为任务清单中任务指派优先级
        + 指派特定的人来完成任务清单上的各个特性
        + 要灵活。充分利用变更。
    + **一个团队处理一个特性集的时间越久，改变特性集时他们就会越恼火。** 
    + **一拿到任务清单你就要马上审查，立即发出反馈（包括正面和负面反馈）。** 及时的反馈会有惊人的促进作用。

###  附录
+ 附录B 源代码管理
    + 如何选择，注意以下特性
        + 标签：为特定版本建立标签是否容易？
        + 合并：自动还是手动合并？
        + 多项目项目：定义项目之间的依赖关系是否困难？
        + 易用性：团队使用的编辑器或IDE是否集成了这个工具？可以嵌入到你的构建脚本中吗？
        + 可伸缩性：能处理所有文件，项目，用户。而且不会丢失或破坏文件？
        + 性能：基本操作是否足够快而值得人们去做？
+ 附录C 脚本构建工具
	+ 操作系统脚本语言(shell,批文件)
	+ make
	+ Automake
+ 附录D 持续集成系统
+ 附录E 问题跟踪软件
+ 附录F 开发方法
+ 附录G 测试框架
    + 可用的测试框架（自动化测试框架）
        + SUnit
        + JUnit
        + JUnitPerf
        + HTMLUnit
        + HTTPUnit
        + JWebUnit
    + 可用的测试框架（测试工具）
        + Cobertura
        + Clover
        + Fit
        + WinRunner
        + Empirix-Tester
+ 附录H 建议阅读书目
    + 通用
        + 《程序员修炼之道》
        + 《精通正则表达式》
        + 《人月神话》
        + 《计算机程序设计艺术》
        + 《死亡之旅》
        + 《重构：改善既有代码的设计》
        + 《重构与模式》
        + 《企业集成模式》
        + 《修改代码的艺术》
        + 《代码大全》
    + Ruby
    + Java
        + 《项目自动化之道》
        + 《单元测试之道Java版》
    + 软件方法
    + 源代码管理
    + 其它
        + 《The little Schemer》
        + 《Dynamic HTML权威指南》
        + 《Bugs in Writing: A Guide to Debugging Your Prose》
        + 《UML精粹》
    + 领导力和关系
        + 《领导力21法则》

## 收获
+ 在chap5的常见问题，以及附录里面给我的思考挺多，但谈不上收获，因为有这种状况，不一定是同一样的原因，需要有多种方式去处理。
+ 我觉得IT领域有方面的问题：(1)如何去实现项目；(2)如何去管理项目。这本书更多是去讲管理，如果用工具去管理这些代码本身并能高效率的工作，第二是去管理团队人员。
+ 看起来很薄的一本书，也是读了几个月啊，虽然中途都没读，因为有了10月8日这个deadline，我20160917才开始捡起来好好读了一下。