##  缘起
+ 具体啥时候下载想看的，已经记不得了。
+ 作者是**王磊**，2016年1月第1版。
+ 2017-02-03开始看，第1个番茄钟读了1-11(28/239)，按这个进度，全书需要22个番茄钟才能读完。

##  内容
+ 目录 i(12/239)
###  Part1 基础篇  1(18/239)
+ **系统架构设计：**描述了在应用系统的内部，如何根据业务、技术、组织、灵活性、可扩展性以及可维护性等多种因素，将应用系统划分成不同的部分，并使这些部分彼此之间相互分工、相互协作，从而为用户提供某种特定价值的方式。
+ 对于这种功能集中、代码中心化、一个发布包、部署后运行在同一进程的应用程序，我们通常称之为**单块架构应用**。
####  chap1 单块架构及其面临的挑战 3(20/239)
+ 1.1 三层应用架构
	+ *数据访问层：*关注的是应用程序是如何有效地将数据存储到数据库、文件系统或者其它存储介质中。
	+ 三层架构的优势
		+ 解决了应用程序中代码间调用复杂、代码职责不清的问题。（在各层间定义接口，接口与实现分离。）
		+ 解决了企业内部如何有效根据技能调配人员，提高生产效率的问题。
+ 1.2 单块架构
	+ 基于Ruby On Rails的单块架构应用。 **Capistrano**
	+ *对于单块架构应用的定义，其实是在分层软件架构设计的系统基础之上，从部署模式、运行模式角度去考虑的一种定义方式。*
	+ 单块架构的优势
		+ 易于开发
		+ 易于测试：所有功能都运行于一个进程中。
		+ 易于部署
			+ 使用SCP远程复制到指定目录
			+ 使用某些自动化的工具
		+ 易于水平伸缩
			+ *这里的水平伸缩*是什么意思？ lionel（克隆，新建一个服务器节点）
	+ **单块架构面临的挑战**
		+ 维护成本增加
			+ 分析，定位，修复缺陷的成本。
		+ 持续交付周期长
			+ 3点做版本的话，在这个过程中，是没有办法提交代码的。
		+ 新人培养周期长
		+ 技术选型成本高
			+ ThoughtWorks的技术雷达
		+ 可扩展性差
			+ 垂直扩展Scale-up：*多买硬件*。
			+ 水平扩展Scale-out：*建立一个集群，通过在集群中不断添加新节点。*
		+ 构建全功能团队难
			+ **康威定律：** 一个组织的设计成果，其结构往往对应于这个组织中的沟通结构。

####  chap2 微服务架构综述 13(30/239)
+ 2.1 什么是微服务架构
	+ Martin Flowler的定义。 
		+ *每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境，类生产环境等。*
	+ 多微才够微
		+ *康威生命游戏的规则*--代码实现
		+ 2周内重写该服务
		+ 团队觉得好才是真的好
			+ 业务独立性
			+ 团队自主性
	+ 单一职责
		+ SOLID原则
			+ S表示的是SRP（Single Responsibility Principle）：一个对象应该只有一个发生变化的原因。 *linux就是这样的*
	+ 轻量级通信
		+ 定义：通信机制与语言无关、平台无关的交互方式。
		+ 通信的格式：xml或者json
		+ 通信的协议：http
		+ REST是实现服务之间互相协作的轻量级通信机制之一。
	+ 独立性
		+ 在应用的交付过程中，开发、测试以及部署的独立。
			+ 现在是 开发-测试-构建-部署
			+ 以前是 多个开发一起发布-测试-构建-部署
	+ 进程隔离
		+ 需要将进程停掉，才能进行新的部署，无法进行独立部署。
	+ **微服务架构** 其实是将单一的应用程序划分成一组小的服务，每个服务都是具有业务属性的独立单元，同时能够被独立开发、独立运行、独立测试和独立部署。 
+ 2.2 微服务的诞生背景 22(39/222)
	+ **互联网时代的产品通常有两类特点：需求变化快和用户群体庞大。**
	+ 2.2.4 容器虚拟化技术 23(40/239)
+ 2.3 微服务架构与SOA
	+ 1906年，Gartner提出了SOA。
		+ SOA阐述了“对于复杂的企业IT系统，应按照不同的、可重用的粒度划分，将功能相关的一组功能提供者组织在一起为消费者提供服务。”
	+ 2.3.2 微服务与SOA 
		+ *其实两者的思想一致*，但两者有区别
		+ 微服务只是SOA方面的一个子集
+ 2.4 微服务的本质  26(43/239)
	+ 服务作为组件
		+ *共享库的变化意味着整个应用要被更新，并且需要被重新部署。*
		+ 同共享库相比，微服务是通过语言无关、平台无关的轻量级通信机制协作，灵活性非常高。
		+ **微服务不足之处：**分布式调用比进程内调用更消耗时间，并且严重依赖于网络的可靠性与稳定性。
	+ 围绕业务组织团队
	+ 关注产品而非项目
		+ **项目模式：**当项目启动后，企业或组织会从不同的技能资源池中抽取相关的资源，组建团队并完成项目。
		+ 让团队负责整个服务的生命周期。
	+ 技术多样性
	+ 业务数据独立
		+ 能够随着业务的发展，选择更适合的工具管理或迁移业务数据。
		+ 能够随着业务的发展，提供业务数据接口集成，而不是以数据库的方式同其它服务集成。
	+ 基础设施自动化
	+ 演进式架构
+ 2.5 微服务不是银弹 【使用过程中要考虑的因素】 34(51/239)
	+ 分布式系统的复杂度
		+ 性能：网络时延以及带宽的影响。
		+ 可靠性
		+ 异步：享受非阻塞的优势时，也大大增加了功能实现的复杂度。
		+ 数据一致性
		+ 工具
	+ 运维成本
		+ 配置
		+ 部署
		+ 监控与告警
		+ 日志收集
	+ 部署自动化
	+ DevOps与组织架构
	+ 服务间依赖测试
	+ 服务间依赖管理

###  Part2 实践篇
####  chap3 构建第一个服务 41(58/239)
+ 3.1 场景分析  41(58/239)
	+ 引入REST。
	+ *学习一下如何定义当前的场景分析的，用REST定义的* lionel 
+ 3.2 任务拆分  43(60/239)
	+ Hello World API
	+ 代码测试与静态检查
	+ 构建Docker映像
	+ 部署Docker映像
	+ 持续集成与交付
		+ Snap-CI
	+ 监控与告警
		+ Nagios 
	+ 日志聚合
		+ Splunk
	+ 功能迭代

####  chap4 Hello World API 45(62/239)
+ 4.1 API的实现
	+ 开发语言是 Ruby
	+ Web框架--- Grape。
	+ 4.1.3 API的具体实现 47(64/239)  【这个语言不太熟悉，lionel，没有进行练习，自己可以用别的语言进行实现】
+ 4.2 代码测试与静态检查
	+ 使用RSpec作为代码测试具
	+ 在Hello World API中，我们使用了Rack作为Web抽象接口。
	+ SimpleCov是Ruby世界里统计代码测试覆盖率较方面的工具
	+ 笔者的实践中，大部分项目都使用Rubocop完成代码的静态检查
	+ 笔者的实践中，大部分项目都使用Cane完成代码的复杂度检查

####  chap5 构建Docker映像 61(78/239)
+ 5.1 定义Dockerfile  （我使用的时候，没有使用在Dockerfile里写内容，然后自动执行）
+ 5.2 配置Docker主机 63(80/239)
	+ 在mac或win上需要安装 *Boot2docker* 这样一个工具
+ 5.3 构建docker映像
	+ `docker build -t name `; `docker images | grep name`
+ 5.4 运行docker容器 
	+ `docker run -p 8080:8080 name`
+ 5.5 发布docker映像
	+ 发布到Docker Hub
	+ 发布到私有的Docker仓库
	+ 发布到云存储
 
####  chap6 部署Docker映像 71(88/239)
+ 6.1 基础设施AWS
	+ EC2是指Elastic Compute Cloud
+ 6.2 基础设施自动化  Infrastructure As Code
	+ *Chef,Puppet,Ansible,Salt*
+ 6.3 部署Docker映像 80(97/239)
+ 6.4 自动化部署 81(98/239)

####  chap7 持续交互流水线 85(102/239)
+ 7.1 持续集成环境
	+ Snap-CI可以无缝集成Github上的代码库，由TW公司开发，可以方便部署到Heroku或者AWS上。
+ 7.2 提交阶段 87(104/239)
	+ 检测代码库的变化，并按照配置触发相应的处理。
		+ 大多数采用WebHook的方式，当然也有采用轮询的
+ 7.3 验证阶段
	+ 进行功能、性能等的验证
+ 7.4 构建阶段
	+ Docker Hub方式
+ 7.5 发布阶段 
	+ 部署包发布到具体的环境中

####  chap8 日志聚合 97(114/239)
+ 8.1 日志聚合工具简介
	+ Splunk和LogStash
+ 8.2 Splunk的核心
	+ 数据（采集器）转发器
	+ 数据索引器：将收集的数据进行存储，并采用高效的索引方式对日志进行索引。
	+ 搜索、分析和可视化
+ 8.3 安装 Splunk索引
	+ Splunk Light
+ 8.4 安装 Splunk转发
	+ Splunk Forwarder
+ 8.5 日志查找
+ 8.6 告警设置
	+ 保存搜索条件 “Save Search”
	+ 设置“告警阀值”
	+ 定义“告警响应”

####  chap9 监控与告警 45(62/239)
+ 关于监控，业界有许多成熟的产品
	+ Ganglia,Zabbix,NewRelic，Nagios和OneAPM
+ 9.1 Nagios简介
+ 9.2 Nagios的工作原理
	+ 主机+agent的方式运行
+ 9.3 Nagios安装
+ 9.4 Nagios的配置
+ 9.5 监控 name
+ 9.6 告警
	+ PagerDuty是一款能够在系统出现问题时及时发送消息提醒的应用

####  chap10 功能迭代 45(62/239)
+ 10.1 定义模型
+ 10.2 持久化模型
	+ **模型的存取通常使用模型存储模式**  《领域驱动设计》
+ 10.3 定义表现行式
	+ 描述业务模型如何在应用层显示。
		+ 数据展现
		+ 交互方式
+ 10.4 实现API
	+ 为使用者提供管理产品信息的接口
	+ 这里的API主要用来接收请求、高度处理逻辑并返回响应结果，和我们所熟悉的传统Web框架中的controller作用类似。
+ 10.5 服务描述文件 
	+ 对于每个服务而言，都会存在一些描述信息，包括服务的介绍、维护者的信息，以及如何部署、监控和设置告警机制，来帮助团队更好好理解和快速运行服务。

###  Part3 进阶篇  129(146/239)
####  chap11 微服务与持续交付 131(148/239)
+ 从技术上讲，持续交付是软件系统的构建、部署、测试、审核、发布过程的一种自动化实现，而**其中的核心则是部署流水线。**
+ 11.1 持续交付的核心
	+ 持续交付的核心在于三个字：**小，频，快**
		+ 小批量价值流动
		+ 频繁可发布
		+ 快速反馈
+ 11.2 微服务架构与持续交付
+ 开发
	+ 独立代码库
	+ 服务说明文件
	+ 有效的代码版本管理工具
	+ 代码静态检查工具
	+ 易于本地运行
+ 测试
	+ + 137(154/239)
	+ 集成测试的二义性
	+ Mock与Stub
		+ 我们使用Mock框架帮助我们完成对依赖的模拟(Mock)或者打桩(Stub)。
	+ 接口测试
	+ 测试的有效性
+ 持续集成
	+ Jenkins，Bamboo，GO，Travis-CI，Snap-CI
+ 构建
+ 部署
	+ 部署环境
		+ 基于云平台
		+ 基于数据中心
		+ 基于容器技术
	+ 部署方式
		+ 手动部署
		+ 脚本部署
		+ 基础设施部署自动化
		+ 应用部署自动化
		+ 映像部署
		+ 容器部署 
+ 运维
	+ 监控
	+ 告警
	+ 日志聚合

####  chap12 微服务与轻量级通信机制  145(162/239)
+ 12.1 同步通信与异步通信
	+ 同步通信：发送请求，等待，接收响应并处理。*过程实现简单，但会造成阻塞操作。*
	+ 异步通信：发送请求后立即返回，不会造成阻塞，一般适用于耗时操作的处理。
+ 12.2 远程调用RPC
	+ 客户端通过客户代理存根(Stub)，传递函数参数，向服务器端发起函数调用。服务器通过服务器代理存根(Skeleton)，接收到客户端的请求后，对请求进行处理，并在结束后向客户端返回响应，从而完成一次通信。
	+ 远程方法调用
	+ 远程过程调用的弊端
		+ 耦合度高
		+ 灵活性差
+ 12.3 REST
	+ 资源
	+ 表述
	+ 状态转移
	+ 统一接口
	+ REST的优势
	+ REST的不足
		+ 如何标准化资源结构
		+ 如何处理资源的相关链接
		+ 如何有效处理相关资源的链接
		+ 其他需要考虑的因素
			+ 性能：REST是基于HTTP之上的协议
			+ 开发成本：《RESTful in Practice》
+ 12.4 HAL
	+ Hypertext Application Language：轻量级超文本应用描述协议
	+ HAL的核心
		+ 状态
		+ 链接
		+ 子资源
	+ [HAL浏览器](https://github.com/mikekelly/hal-browser) 
+ 12.5 消息队列
	+ 是一种处理节点之间异步通信的实现方式
	+ 核心部分
		+ 持久性
		+ 排队标准
		+ 安全策略
		+ 清理策略
		+ 处理通知
	+ 访问方式
		+ 拉模式
		+ 推模式
	+ 消息队列的优缺点 
+ 12.6 后台任务处理系统【lionel，这部分需要好好看看】
	+ 核心部分
		+ 任务
		+ 队列
		+ 执行器
		+ 定时器
	+ 后台服务与微服务

####  chap13 微服务与测试 171(188/239)


####  chap14 使用微服务架构改造遗留系统 211(228/239) 

## 收获
+ 第2部分：读了两个番茄钟，更多只是了解，并没有去实践作者的东西。
+ 2017-02-08的第1个番茄钟：chap4-6三章内容读完。
+ 2017-02-09的第1个番茄钟：读完了chap11,12两章