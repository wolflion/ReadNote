##  缘起
+ 《设计模式》怎么去入门？更进一步的讲如何去进阶？怎么去代码中应用这些模式？是个问题？想花点时间去内化一下。
+ 2017-03-29开始看这本电子书。

##  内容
###  Part1 模式介绍 14/292
####  chap1 谈面向对象和模式 16/292
+ 1.1 什么是对象
	+ 面向对象的语言一般都有三个基本特征
		+ 封闭（隐藏了数据；隐藏了实现细节；）
		+ 继承
		+ 多态（相同的方式处理不同类型的对象；）
+ 1.2 面向对象的好处
	+ 对象易于理解和抽象
	+ 对象的粒度更大，模块化程度也更高
	+ 更加容易重用代码
	+ 具有可扩充性和开放性
	+ 易于测试和调试
	+ 代码容易维护
+ 1.3 重用	
	+ 随着应用场景的扩大，我们*从方法、结构体、类的重用，上升到软件的重用。*
	+ **有经验的OOP开发人员并不会从头解决问题，他们往往会使用之前的成熟的解决方案来解决类似的问题。**
+ 1.4 模式简史	
+ 1.5 什么是模式	
	+ **模式**是某一上下文环境中一个问题的*“常用”*解决方案。
+ 1.6 学习设计模式的一些常见问题	
	+ 模式有没有标准形式（没有，不代表GoF给出的模式就是标准模式。）
	+ 设计模式和OO什么关系（不代表只有面向对象才有模式）
	+ 能不能创造新的设计模式（完全可以）
	+ 学习了设计模式，就等于学会了设计（用OO的眼光看待和解决问题）
	+ 设计模式是OO设计的根本吗（解决问题才是根本）
	+ 软件的核心是什么（**软件的核心是模型，为复杂领域问题提取精炼的模型是根本。**）
+ 1.7 本章关键词	

####  chap2 第1个模式——模板方法（template method）模式	
+ 2.1 从回家过年说起	
	+ 2.1.1 DRY（don't repeat yourself）	 31/292
	+ 2.1.2 变化+重复，如何维护	
+ 2.2 模板方法（template method）模式	
+ 34/292
	+ 2.2.1 使用继承	
	+ 2.2.2 模板方法模式	
		+ *模板方法定义了一系列算法步骤，子类可以去实现/覆盖其中某些步骤，但不能改变这些步骤的执行顺序。*
+ 2.3 引入回调（callback）	39/292
	+ **回调**表示一段可执行逻辑的引用（或者指针），我们把该引用（或者指针）传递给另外一段逻辑（或者方法）里供这段逻辑适时调用。
	+ 回调在不同语言有不同的实现
		+ C语言里经常使用函数指针实现回调
		+ C#语言里使用代理(delegate)实现
		+ Java语言里使用内部匿名类实现
+ 2.4 总结	43/292
	+ *模板方法模式可以解决某些场景中的代码冗余问题，但也可能引入类的泛滥问题，随后我们介绍了如何结合使用回调避免类的泛滥。*
2.5 本章关键词	

###  Part2 创建对象	 44/292
第3章 单例（singleton）模式	33
3.1 最简单的单例	34
3.2 进阶	35
3.2.1 延迟创建	35
3.2.2 线程安全	36
3.2.3 double-check locking	37
3.2.4 initialization on demand holder	39
3.2.5 singleton的序列化	40
3.3 总结	41
3.4 本章关键词	42
第4章 工厂方法（factory method）模式	43
4.1 工厂方法模式	44
4.1.1 类图	44
4.1.2 创建数据库连接对象	47
4.2 静态工厂方法	52
4.3 总结	53
4.4 本章关键词	54
第5章 原型（prototype）模式	55
5.1 原型模式	56
5.2 寄个快递	57
5.3 实现	57
5.3.1 uml静态类图	57
5.3.2 代码实现	58
5.4 深拷贝（deep copy）	61
5.5 总结	65
5.6 本章关键词	65
第6章 控制反转（ioc）	67
6.1 从创建对象谈起	68
6.2 使用工厂方法模式的问题	70
6.3 inversion of control（控制反转）	71
6.3.1 ioc和di（dependency injection，依赖注入）	72
6.3.2 service locator（服务定位器）	73
6.3.3 dependency injection	76
6.4 总结	91
6.5 本章关键词	92
第三篇 构建复杂结构	93
第7章 装饰器（decorator）模式	95
7.1 记录历史修改	96
7.2 open-closed principle（开放—封闭原则，ocp）	99
7.3 装饰器（decorator）模式	101
7.3.1 类图	101
7.3.2 实现	101
7.3.3 一点变化	107
7.3.4 如何使用	108
7.3.5 测试	108
7.4 装饰器模式的优缺点	110
7.5 总结	111
7.6 本章关键词	111
第8章 代理（proxy）模式	113
8.1 代理（proxy）模式	114
8.1.1 类图	114
8.1.2 访问分布式对象	114
8.2 j2se动态代理	122
8.2.1 类和接口	122
8.2.2 调用原理	124
8.2.3 实现同步	125
8.2.4 总结	131
8.3 和装饰器（decorator）模式的比较	131
8.4 总结	132
8.5 本章关键词	132
第9章 适配器（adapter）模式	133
9.1 打桩	134
9.2 其他适配器模式	137
9.2.1 类适配器	137
9.2.2 双向适配器	138
9.3 测试	139
9.4 和代理（proxy）模式的比较	141
9.5 总结	141
9.6 本章关键词	142
第10章 外观（facade）模式	143
10.1 外观（facade）模式	144
10.2 least knowledge principle（最少知识原则）	144
10.3 懒惰的老板请客	145
10.4 ejb里的外观模式	148
10.5 总结	150
10.6 本章关键词	150
第11章 组合（composite）模式	151
11.1 组合模式概述	152
11.1.1 类图	152
11.1.2 使用组合（composite）模式	153
11.1.3 测试	156
11.2 透明的组合模式	159
11.3 安全的组合模式vs透明的组合模式	162
11.4 还需要注意什么	162
11.5 总结	163
11.6 本章关键词	163
第四篇 行为模式	165
第12章 策略（strategy）模式	167
12.1 既要坐飞机又要坐大巴	168
12.2 封装变化	169
12.3 策略模式	172
12.4 还需要继承吗	173
12.5 优先使用合成而非继承	175
12.6 总结	176
12.7 本章关键词	177
第13章 状态（state）模式	179
13.1 电子颜料板	180
13.2 switch-case实现	180
13.3 如何封装变化	181
13.4 状态模式	186
13.5 使用enum类型	186
13.6 与策略（strategy）模式的比较	191
13.7 总结	191
13.8 本章关键词	192
第14章 观察者（observer）模式	193
14.1 股票价格变了多少	194
14.2 观察者模式	194
14.2.1 如何实现	194
14.2.2 观察者模式	201
14.2.3 java标准库的观察者模式	201
14.3 总结	208
14.4 本章关键词	208
第五篇 终点还是起点	209
第15章 面向切面的编程（aop）	211
15.1 记录时间	212
15.2 aop（aspect-oriented programming）	215
15.2.1 一些重要概念	216
15.2.2 oop实现横切	217
15.2.3 aop实现技术	218
15.3 aop框架介绍	244
15.4 aop联盟（aop alliance）	245
15.5 使用aop编程的风险	245
15.6 oop还是aop	246
15.7 总结	247
15.8 本章关键词	248
第16章 面向对象开发	249
16.1 写在面向对象设计之前	250
16.2 汲取知识	251
16.3 横看成岭侧成峰	253
16.4 提炼模型	254
16.5 应用设计模式	259
16.6 不能脱离实现技术	259
16.7 重构	260
16.8 过度的开发（over-engineering）	262
16.9 总结	263
16.10 本章关键词	264
第17章 结语	265
17.1 感悟	266
17.2 面向对象的开发范式	266
17.3 一些原则	268
17.4 写在模式之后	269
17.5 本章关键词	269
附录A 推荐阅读资源	271
1 Java语言相关学习图书	272
2 J2EE技术相关图书	273
3 面向对象设计相关图书	273
4 给Agile（敏捷）开发人员推荐的书籍	275
5 网站和论坛	275
参考文献	277

## 收获
+ 学习设计模式之前，必须要弄明白**UML中的概念。**
+ **最根本的使用价值**使用设计模式来避免代码的重复。